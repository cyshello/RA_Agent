"""
유틸리티 함수 모듈 - LangChain 기반

OCR 처리, JSON 파싱, 페이지 추출 Chain을 포함합니다.
"""

import json
import PIL
import PIL.Image
import dotenv
import os
import logging
import time
import requests
import uuid
import io
import asyncio

from langchain_core.output_parsers import JsonOutputParser

from .api import ChatRequest, Dispatcher, ModelFactory
from .prompts import EXTRACTION_PROMPT

logger = logging.getLogger(__name__)

def parse_json(response: str | dict | list) -> dict:
    """
    JSON 문자열/리스트를 dict로 파싱하고 구조화
    """
    try:
        # set으로 감싸진 경우 처리
        if isinstance(response, set):
            response = list(response)[0]
        
        # 문자열이면 JSON으로 파싱
        if isinstance(response, str):
            # Markdown 코드 블록 제거 (```json ... ``` 또는 ``` ... ```)
            response = response.strip()
            if response.startswith("```"):
                # 첫 번째 줄 제거 (```json 또는 ```)
                lines = response.split('\n')
                if lines[0].strip().startswith("```"):
                    lines = lines[1:]
                # 마지막 줄 제거 (```)
                if lines and lines[-1].strip() == "```":
                    lines = lines[:-1]
                response = '\n'.join(lines).strip()
            
            parsed = json.loads(response)
        elif isinstance(response, (dict, list)):
            parsed = response
        else:
            raise ValueError(f"Cannot parse response of type {type(response)}")
        
        # 리스트가 온 경우 딕셔너리로 변환
        if isinstance(parsed, list):
            result = {}
            for item in parsed:
                if isinstance(item, dict):
                    # text와 다른 정보가 있으면 병합
                    if "text" in item:
                        # bounding_box 같은 메타데이터는 제외하고 text만 추출
                        text = item["text"]
                        # 텍스트를 키-값으로 변환 (첫 줄을 키로 사용)
                        lines = text.split('\n')
                        if lines:
                            key = lines[0].strip()
                            value = '\n'.join(lines).strip()
                            result[key] = value
                    else:
                        result.update(item)
            return result
        
        # 이미 dict면 그대로 반환
        elif isinstance(parsed, dict):
            return parsed
        
        return {}
        
    except json.JSONDecodeError as e:
        raise ValueError(f"Failed to parse JSON: {e}\nResponse: {response}")
    except Exception as e:
        raise ValueError(f"Error parsing response: {e}\nResponse: {response}")

def parse_upstage(response: str | dict | list) -> list[str]:
    """
    Upstage OCR 결과에서 HTML을 추출하고 유니코드를 디코딩
    
    Args:
        response: Upstage OCR 결과 (JSON 문자열, dict, 또는 list)
        
    Returns:
        디코딩된 텍스트 리스트
        
    Example:
        >>> response = {"elements": [{"content": {"html": "<p>캐시닥</p>", ...}, ...}]}
        >>> parse_upstage(response)
        ['캐시닥', ...]
    """
    try:
        from html.parser import HTMLParser
        
        class HTMLTextExtractor(HTMLParser):
            def __init__(self):
                super().__init__()
                self.text = []
            
            def handle_data(self, data):
                if data.strip():
                    self.text.append(data.strip())
        
        # 문자열이면 JSON으로 파싱
        if isinstance(response, str):
            parsed = json.loads(response)
        elif isinstance(response, (dict, list)):
            parsed = response
        else:
            raise ValueError(f"Cannot parse response of type {type(response)}")
        
        text_list = []
        
        # Upstage OCR 응답 구조: {"elements": [...], ...}
        if isinstance(parsed, dict):
            elements = parsed.get("elements", [])
            if not elements and "content" in parsed:
                # 단일 요소인 경우
                elements = [parsed]
        elif isinstance(parsed, list):
            elements = parsed
        else:
            elements = []
        
        for item in elements:
            if isinstance(item, dict):
                # content.html 필드 찾기
                if "content" in item and isinstance(item["content"], dict):
                    html = item["content"].get("html", "")
                    if html:
                        # HTML에서 텍스트 추출
                        parser = HTMLTextExtractor()
                        try:
                            parser.feed(html)
                            extracted = " ".join(parser.text)
                            if extracted:
                                text_list.append(extracted)
                        except:
                            # HTML 파싱 실패시 content.text 사용
                            text = item["content"].get("text", "")
                            if text:
                                text_list.append(text)
        
        return text_list
        
    except json.JSONDecodeError as e:
        raise ValueError(f"Failed to parse JSON: {e}\nResponse: {response}")
    except Exception as e:
        raise ValueError(f"Error parsing Upstage response: {e}\nResponse: {response}")

def parse_upstage_to_html(response: str | dict | list, output_file: str = None) -> str:
    """
    Upstage OCR 결과에서 HTML을 추출하여 하나의 완전한 HTML 문서로 생성
    
    Args:
        response: Upstage OCR 결과 (JSON 문자열, dict, 또는 list)
        output_file: 저장할 HTML 파일 경로 (선택사항)
        
    Returns:
        완전한 HTML 문서 문자열
        
    Example:
        >>> response = {"elements": [{"content": {"html": "<p>캐시닥</p>", ...}, ...}]}
        >>> html = parse_upstage_to_html(response, "output.html")
    """
    try:
        # 문자열이면 JSON으로 파싱
        if isinstance(response, str):
            parsed = json.loads(response)
        elif isinstance(response, (dict, list)):
            parsed = response
        else:
            raise ValueError(f"Cannot parse response of type {type(response)}")
        
        # Upstage OCR 응답 구조: {"elements": [...], ...}
        if isinstance(parsed, dict):
            elements = parsed.get("elements", [])
            if not elements and "content" in parsed:
                # 단일 요소인 경우
                elements = [parsed]
        elif isinstance(parsed, list):
            elements = parsed
        else:
            elements = []
        
        # HTML 조각들을 모으기
        html_parts = []
        for item in elements:
            if isinstance(item, dict):
                # content.html 필드 찾기
                if "content" in item and isinstance(item["content"], dict):
                    html = item["content"].get("html", "")
                    if html:
                        html_parts.append(html)
        
        # 완전한 HTML 문서 생성
        full_html = """<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Upstage OCR Result</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            line-height: 1.6;
        }
        p {
            margin: 10px 0;
        }
    </style>
</head>
<body>
"""
        full_html += "\n".join(html_parts)
        full_html += """
</body>
</html>"""
        
        # 파일로 저장 (선택사항)
        if output_file:
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(full_html)
            logger.info(f"HTML 파일이 저장되었습니다: {output_file}")
        
        return full_html
        
    except json.JSONDecodeError as e:
        raise ValueError(f"Failed to parse JSON: {e}\nResponse: {response}")
    except Exception as e:
        raise ValueError(f"Error parsing Upstage response to HTML: {e}\nResponse: {response}")

def generateSkeleton(arg : ChatRequest):
    """
    슬라이드별로 분석한 JSON 데이터를 받아 맥락 파악, 전체적인 구조를 맞추어 skeleton prompt 생성
    """
    pass

async def extractJSON(image: PIL.Image.Image, dispatcher: Dispatcher, page_num: int = None, start_time_base: float = None, debug: bool = False, ocr_provider: str = "CLOVA", model_provider: str = "openai", model_name: str = "gpt-4o", company=None) -> tuple[dict, str]:
    """
    이미지에서 JSON 데이터를 추출하는 LangChain 기반 함수
    
    Args:
        image: 분석할 PIL Image 객체
        dispatcher: API 디스패처 (rate limiting 용도)
        page_num: 페이지 번호
        start_time_base: 전체 분석 시작 시간
        debug: 디버그 모드 여부
        model_provider: AI 모델 제공자 ("openai" 또는 "gemini")
        model_name: 사용할 구체적인 모델명
        company: Company 객체 (API 호출 카운터 증가용)
    
    Returns:
        tuple: (추출된 JSON dict, OCR 텍스트)
    """
    page_start_time = time.time()
    page_label = f"페이지 {page_num}" if page_num is not None else "페이지"
    
    if debug:
        if start_time_base:
            elapsed_from_main = page_start_time - start_time_base
            logger.info(f"{page_label} 분석 시작 (전체 시작 후 {elapsed_from_main:.2f}초)")
        else:
            logger.info(f"{page_label} 분석 시작")

    # 1. OCR 실행 (별도 스레드에서 실행하여 블로킹 방지)
    loop = asyncio.get_event_loop()
    img_byte_arr = io.BytesIO()
    image.save(img_byte_arr, format='PNG')
    img_byte_arr = img_byte_arr.getvalue()
    
    # CLOVA OCR 사용
    lines = await loop.run_in_executor(None, CLOVA_ocr, img_byte_arr)
    
    # OCR 호출 카운터 증가
    if company:
        company.ocr_call_count += 1

    ocr_text = "\n".join(lines)
    
    # OCR 완료 시간 로깅 (debug 모드일 때만)
    if debug:
        ocr_elapsed = time.time() - page_start_time
        if start_time_base:
            total_elapsed_ocr = time.time() - start_time_base
            logger.info(f"{page_label} OCR 완료 (전체 시작 후 {total_elapsed_ocr:.2f}초, OCR 소요: {ocr_elapsed:.2f}초)")
        else:
            logger.info(f"{page_label} OCR 완료 - 소요 시간: {ocr_elapsed:.2f}초")

    # 2. LangChain 기반 추출 - ChatRequest를 통해 dispatcher로 전달
    # 프롬프트 템플릿에서 메시지 추출
    system_msg = EXTRACTION_PROMPT.messages[0].prompt.template
    user_template = EXTRACTION_PROMPT.messages[1].prompt.template
    user_msg = user_template.format(ocr_text=ocr_text)
    
    request = ChatRequest(
        provider=model_provider,
        model=model_name,
        messages=[
            {"role": "system", "content": system_msg},
            {"role": "user", "content": user_msg}
        ],
        input="with-image",
        image=image,
        output="json"
    )

    response = await dispatcher.dispatch(request)
    
    # LLM 호출 카운터 증가
    if company:
        company.llm_call_count += 1
    
    # 3. JSON 파싱
    response = parse_json(response)

    assert isinstance(response, dict), "Response is not a valid JSON"
    
    # 소요 시간 및 결과 로깅 (debug 모드일 때만)
    if debug:
        page_elapsed = time.time() - page_start_time
        if start_time_base:
            total_elapsed = time.time() - start_time_base
            logger.info(f"{page_label} 분석 완료 (전체 시작 후 {total_elapsed:.2f}초, 페이지 소요: {page_elapsed:.2f}초)")
        else:
            logger.info(f"{page_label} 분석 완료 - 소요 시간: {page_elapsed:.2f}초")
        logger.debug(f"{page_label} 결과: {response}")
    
    return response, ocr_text

#### OCR 

import pytesseract

def pyt_ocr(image: PIL.Image) -> list[str]:
    """
    이미지에서 텍스트 추출
    """
    text = pytesseract.image_to_string(image, lang='eng+kor')
    ## NOTE : 한국어, 영어만 됨
    lines = text.split('\n')
    lines = [line.strip() for line in lines if line.strip()]
    return lines

def paddle_ocr(image: PIL.Image, use_gpu: bool = True) -> list[str]:
    """
    PaddleOCR을 사용하여 이미지에서 텍스트 추출
    
    Args:
        image: PIL Image 객체
        use_gpu: GPU 사용 여부 (기본값: True)
    
    Returns:
        추출된 텍스트 라인 리스트
    """
    from paddleocr import PaddleOCR
    import numpy as np
    
    # PaddleOCR 초기화 (한국어+영어)
    # device='gpu' 또는 'cpu'로 지정
    device = 'gpu' if use_gpu else 'cpu'
    ocr = PaddleOCR(use_angle_cls=True, lang='korean', device=device)
    
    # PIL Image를 numpy array로 변환
    img_array = np.array(image)
    
    # OCR 수행
    result = ocr.ocr(img_array, cls=True)
    
    # 결과 파싱
    lines = []
    if result and result[0]:
        for line in result[0]:
            if line and len(line) >= 2:
                text = line[1][0]  # (text, confidence)에서 text 추출
                if text.strip():
                    lines.append(text.strip())
    
    return lines

def paddle_ocr_with_bbox(image: PIL.Image, use_gpu: bool = True) -> list[dict]:
    """
    PaddleOCR을 사용하여 이미지에서 텍스트와 bounding box 추출
    
    Args:
        image: PIL Image 객체
        use_gpu: GPU 사용 여부 (기본값: True)
    
    Returns:
        추출된 텍스트 정보 리스트. 각 항목은 다음 형식의 dict:
        {
            'text': str,           # 인식된 텍스트
            'confidence': float,   # 신뢰도 (0~1)
            'bbox': list,          # bounding box 좌표 [[x1,y1], [x2,y2], [x3,y3], [x4,y4]]
        }
    """
    from paddleocr import PaddleOCR
    import numpy as np
    
    # PaddleOCR 초기화 (한국어+영어)
    device = 'gpu' if use_gpu else 'cpu'
    ocr = PaddleOCR(use_angle_cls=True, lang='korean', device=device)
    
    # PIL Image를 numpy array로 변환
    img_array = np.array(image)
    
    # OCR 수행
    result = ocr.ocr(img_array, cls=True)
    
    # 결과 파싱
    ocr_results = []
    if result and result[0]:
        for line in result[0]:
            if line and len(line) >= 2:
                bbox = line[0]  # bounding box 좌표
                text_info = line[1]  # (text, confidence)
                text = text_info[0]
                confidence = text_info[1]
                
                if text.strip():
                    ocr_results.append({
                        'text': text.strip(),
                        'confidence': confidence,
                        'bbox': bbox
                    })
    
    return ocr_results

def CLOVA_ocr(image) -> list[str]:
    """
    CLOVA OCR API를 사용하여 이미지에서 텍스트 추출
    """
    dotenv.load_dotenv()
    from dotenv import find_dotenv
    env_path = find_dotenv()

    api_url = dotenv.get_key(env_path, "CLOVA_api_url")
    secret_key = dotenv.get_key(env_path, "CLOVA_secret_key")

    request_json = {
        'images': [
            {
                'format': 'png',
                'name': 'demo'
            }
        ],
        'requestId': str(uuid.uuid4()),
        'version': 'V2',
        'timestamp': int(round(time.time() * 1000))
    }

    payload = {'message': json.dumps(request_json).encode('UTF-8')}
    files = [
        ('file', ('image.png', image, 'image/png'))
    ]
    headers = {
        'X-OCR-SECRET': secret_key
    }

    response = requests.request("POST", api_url, headers=headers, data=payload, files=files)

    results = []
    if response.json().get('images') is not None:
        for i in response.json()['images'][0]['fields']:
            text = i['inferText']
            results.append(text)

    return results


def Upstage_ocr(image, model="ocr") -> list[str]:
    """
    Upstage OCR API를 사용하여 이미지에서 텍스트 추출
    """

    dotenv.load_dotenv()
    from dotenv import find_dotenv
    env_path = find_dotenv()

    api_key = dotenv.get_key(env_path, "UPSTAGE_api_key")
     
    url = "https://api.upstage.ai/v1/document-digitization"
    headers = {"Authorization": f"Bearer {api_key}"}
    files = {"document": image}
    if model == "document-parse":
        data = {"ocr": "force", "base64_encoding": "['table']", "model": "document-parse"} # NOTE: document parsing 모델
    else:
        data = {"model": "ocr"} # NOTE: OCR만
    response = requests.post(url, headers=headers, files=files, data=data)

    response_data = response.json()
    
    # 에러 체크
    if "error" in response_data:
        error_msg = response_data["error"].get("message", "Unknown error")
        error_code = response_data["error"].get("code", "")
        raise RuntimeError(f"Upstage OCR API Error ({error_code}): {error_msg}")
    
    texts = []
    # pages[0].words에서 텍스트 추출
    for w in response_data["pages"][0]["words"]:
        texts.append(w["text"])
    
    return texts